Linux カーネルのコーディング規約です。
全18章あるのですが、HULFTの開発に有用な1～8と11～12章のみ抜粋しています。
基本的にはこの規約に従ってコードを書くようにしてください。

以下をLinuxカーネルのコーディング規約にはない例外事項とします。
この例外事項も規約の一部に含めますので、以下の5点も遵守ください。

(1) Windows上ではtabは4文字で良い

(2) 1行80文字は必ず守らなければいけないわけではない。(100～110文字程度は許容します)

(3) if文で一行のみの処理がある場合、コーディング規約には以下の記載があります。
      ＞１つの文しか実行しないところに、必要のない括弧を使わないでください。
      ＞
      ＞
      ＞if (条件文)
      ＞        action();
    上記は以下の様に書いてください。
    (Linuxカーネルコーディング規約の抜粋部分も変更しましたのでご注意ください)
      if (条件文) {
              action();
      }

(4) 関数の一部分を修正する場合、現行のソースのルールに合わせるか、本規約を適用
    するかについては、適宜相談。

(5) 関数が実装されているソースファイル以外のソースファイルから参照される関数には
    関数ヘッダを作成すること。
    関数ヘッダはdoxygenにて解釈できる書式にて記載すること。
    以下に例を記載する。

    /**
     * 関数機能を記載する
     *
     * @note (1)NNNNファイルからMMMM実行情報を取得。
     *       (2)ループでOOOO起動し、PPPPを出力する。
     *
     * @param[in] in_param_xx
     *              XXXXX情報構造体
     * @return
     *              0:正常終了
     *              301:AAAAA失敗
     *              302:BBBBB無し
     *              303:CCCCCエラー
     *              304:DDDDDタイムアウト
     *              305:EEEEEエラー
     *              306:FFFFF失敗
     *              307:GGGGG失敗
     */
    関数ヘッダに使用できるキーワードや詳細な書き方は下記のURLを参照ください。
      http://denshin8.esprix.net/den8dev/doxygen.html#FUNC

=============================================================

　　　　第１章 - インデント
　　　　第２章 - 長い行と長い文字列を分離して短くすること
　　　　第３章 - 括弧の位置と空白
　　　　第４章 - 名前の選択
　　　　第５章 - Typedef
　　　　第６章 - 関数
　　　　第７章 - 関数終了コードの共通化(goto out)
　　　　第８章 - コメント
　　　　第１１章 - データ構造
　　　　第１２章 - マクロ、列挙型および RTL

=============================================================

　http://archive.linux.or.jp/JF/JFdocs/kernel-docs-2.6/CodingStyle.html


                Linux カーネル コーディング規約

この文書では、Linux カーネルのソースコードの好ましい書き方を簡単に説明し
ています。コーディングの仕方は非常に好みが分かれるものだから、私の考えを
強制するつもりはありません。でも、これから説明することは私が管理しなくて
はならないこと全てに当てはまる方針ですし、私は自分が管理しないものでも、
この方針で書かれていれば良いのにとさえ思っています。せめて、この文書に
書かれたことだけでも守ってください。

まず最初に、「GNU コーディング規約」(GNU coding standards)を入手して印刷
してみてください。でも、読むために印刷するのではありません。印刷した物を
燃やすのです。この儀式は晴れがましい意思表示なのです。

とにかく、本題に入りましょう -

                第１章 - インデント

タブは８文字です。なので、インデントも８文字です。インデントを４文字にし
たり、更には２文字にしようというような異教徒の運動までありますけれど、こ
れはπ＝３と決めてしまおうという主張と同じようなものです。

論拠 - そもそもインデントとは、ブロックの始まりと終わりをはっきりさせるた
めのものです。大きなインデントの恩恵は、２０時間連続してモニタを眺めてい
るときなどに特に実感できます。

さて、人によっては「８文字単位にインデントをすると、プログラムが右に行き
過ぎて、８０文字の画面では読みにくくなってしまう」と主張するでしょう。こ
ういう人達には、「３段階より多くのインデントをするような場合は、プログラ
ムそのものが良くないのだから、そこを修正しなさい」と言いましょう。

要するに、８文字単位のインデントをすればプログラムが読みやすくなり、その
上、ネストが深過ぎる関数を書いてしまった場合の警告にもなります。警告を素
直に聞き入れてください。

switch 文でインデントのレベルを浅くするのに推奨する方法は、「case」ラベル
を「ダブルインデント」にする代わりに、「switch」とそれに含まれる「case」ラ
ベルを同じ列にそろえることです。例 -

        switch (suffix) {
        case 'G':
        case 'g':
                mem <<= 30;
                break;
        case 'M':
        case 'm':
                mem <<= 20;
                break;
        case 'K':
        case 'k':
                mem <<= 10;
                /* fall through */
        default:
                break;
        }

何か隠したいことがない限り、１行に複数の文を書かないでください -

        if ( 条件文 ) ここですること;
          どんな時でもすること;

１行に複数の処理を書かないでください。カーネルのコーディングスタイルは、と
ても単純であるべきです。凝った表現は避けてください。

コメントやドキュメーテンション以外では、決して空白でインデントしてはいけ
ません（ただし Kconfig ファイルを除く）。ちなみに上記の例はあえてやって
います。

まともなエディタを使ってください、そして行の最後に空白文字を置かないでく
ださい。

                第２章 - 長い行と長い文字列を分離して短くすること

コーディング規約の目的は、一般的なツールを使用した場合に、読みやすさと保
守のしやすさを確保することにあります。

行の長さは８０カラムが限界で、これは強く推奨される制限です。

８０カラムより長い文は、分かりやすいように分割しましょう。分割の２行目以
降は１行目より常にかなり短くし、かなり右に置きます。同じことが、長い引数
リストを持つ関数宣言にも適用できます。同様に、長い文字列もより短い文字列
に分割できます。これに対する唯一の例外は、８０カラムを越えることで、読み
やすさが格段に向上する上に、情報が隠されない場合です。

void fun(int a, int b, int c)
{
        if ( 条件文 ) {
                printk(KERN_WARNING "Warning this is a long printk with "
                                    "3 parameters a: %u b: %u "
                                    "c: %u \n", a, b, c);
        } else {
                次の文 ;
        }
}


                第３章 - 括弧の位置と空白

Ｃ言語のコーディング規約で、もう一つ、よく話題になるのが括弧の位置です。
インデントの場合とは違い、どこに括弧を置くのが優れているかというような
技術的な根拠はほとんどありません。それでも好ましい括弧の位置というのは
あって、Kernighan と Ritchie 両氏によるＣ言語の聖典（通称 K&R と呼ばれ
る「プログラミング言語Ｃ」）に示されているのです。ブロックの開始行の行
末に開始括弧を置いて、ブロックの最終行の始まりに終了括弧を置くというも
ので、次のようになります -

        if ( xが真 ) {
                yを実行;
        }

これは、関数以外のブロック全て（if、switch、for、while、do）にあてはまり
ます。例 -

        switch (action) {
        case KOBJ_ADD:
                return "add";
        case KOBJ_REMOVE:
                return "remove";
        case KOBJ_CHANGE:
                return "change";
        default:
                return NULL;
        }

ただし、関数定義の括弧だけは例外で、開始括弧は次の行の始まりに置きます -

        int 関数名(int x)
        {
                関数の中身
        }

ところが世界中の異教徒たちは、この一貫性の無さが、...そうですね...一貫
性が無いと文句を言っています。しかし、正しい思想を持った人々は (a)
K&R は正しく、しかも(b) K&R が正しいのだとわかっています。それに、とに
かく関数定義というのは特別なものなのです（Ｃ言語の中で関数定義のネスト
はできません）。


ここで一つ注意しておきます。終了括弧は普通、終了括弧だけの行になります
が、終了括弧で文が終わらない場合にはその行が続くことになります。すなわ
ち do 文では "while" が、 if 文では "else" が来ることがあります -


        do {
                doループの中身
        } while ( 条件文 );

や、

        if (x == y) {
                ..
        } else if (x > y) {
                ...
        } else {
                ....
        }


論拠 - 聖典「K&R」

それに、ここで説明したように括弧を置けば、読みやすさを犠牲にしないで、
空行（というか、ほとんど空行）を最小限にとどめることができるでしょう。画
面に表示できる行は限られていますが（ここでは２５行の端末画面を念頭に置い
て話をしています）、このようにして空行を減らした分、コメントを入れること
ができます。

１つの文しか実行しないところにも、中括弧を使用するようにしてください。

if ( 条件文 ) {
        action();
}

                ３．１ - 空白


Linux カーネルスタイルにおける空白の使用方法は、（主に）関数かキーワードか
によって変わります。（大部分の）キーワードの後には、空白を使ってください。
注意すべき例外は、関数のように見える sizeof、typeof、alignof、__attribute__
です。（これらは、"struct fileinfo info;" の定義後に "sizeof info" が使える
ように、言語仕様上、必ずしも括弧は必要ではないけれども、Linux では通常、括
弧を使います）。


だから以下のキーワードの後には、空白を使ってください -

        if, switch, case, for, do, while

しかし、sizeof、typeof、alignof、__attribute__ の後には空白を使わないでくだ
さい。例 -

        s = sizeof(struct file);


括弧内の式の前後に、空白を使わないでください。以下の例は悪い例です -

        s = sizeof( struct file );

ポインタデータ、またはポインタ型を返す関数を定義するとき、「*」の良い使い
方はデータ名または関数名にはつけて、型名につけません。例 -

        char *linux_banner;
        unsigned long long memparse(char *ptr, char **retptr);
        char *match_strdup(substring_t *s);

以下のように、たいていの二項演算子や三項演算子の演算子の回りに（前後に）、
空白を１文字使ってください -

        =  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :


しかし単項演算子の後には、空白を使わないでください -

        &  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined

後置インクリメント単項演算子や後置デクリメント単項演算子の前には、空白を使
わないでください -

        ++  --

前置インクリメント単項演算子や前置デクリメント単項演算子の後に空白を使わな
いでください -

        ++  --

そして、構造体演算子「.」と「->」の前後に、空白を使わないでください。


行末に無駄な空白を残さないでください。気の利いたインデント機能を持つエディ
タは、新しい行の先頭に適切な空白を挿入してくれるので、次の行から、すぐにコ
ードを書き始めることができます。しかしながら、そのようなエディタの中には、
あなたが空白行を残そうとして、コードを追加しなかった時、空白を削除してくれ
ないものがあります。その結果、行末に無駄な空白が残ります。

git は行末に無駄な空白のあるパッチに対して、警告してくれるでしょう、そして
無駄な空白を任意に取り除くことができます - しかしながら、複数のパッチを適用
する場合、git がある行末の無駄な空白を削除することで、同じ行を変更する、あと
から適用するパッチが失敗するかもれしれません。


                第４章 - 名前の選択

Ｃ言語はスパルタ言語なのですから、それにふさわしく変数や関数を命名しまし
ょう。Modula-2 や Pascal のプログラマとは違って、Ｃ言語プログラマは「こ
の変数は一時的に使われるカウンターである(ThisVariableIsATemporaryCounter)」
などというような気のきいた名前は使いません。Ｃ言語プログラマは、"tmp" な
どの十分に書きやすく、それでいて少なくとも分かりにくくはならない変数名を
選ぶものです。

大文字小文字を混ぜたような名前は嫌がられますが、グローバル変数には、意味
のわかる名前が必要です。グローバル関数に "foo" などという無意味な名前を
付けることは不快感を与えてしまいます。

グローバル変数（本当に必要な時にだけ使うこと）には意味がよく分かる名前
を付けてください。グローバル関数も同じで、アクティブなユーザ数を数える
グローバル関数には "count_active_users()" やそれに類似した名前を使うべ
きであり、"cntusr()" を使うべきではありません。


関数の型を関数名に含める方式（いわゆるハンガリー記法）は、明らかに間違っ
ています。そんなことをしなくても、とにかくコンパイラは型を知っていますし、
型のチェックもできます。結局はプログラマ自身を混乱させるだけです。
Microsoft がバグの多いプログラムを作っているのも不思議ではありません。

ローカル変数の名前は短くて、変数の特徴を表したものにします。ループの実
行回数を数える適当な整数カウンタを選ぶならば、おろらく "i" と名付けるべ
きです。誤解されることもないのに、loop_counter と呼ぶことは実りがありま
せん。同様に、一時的に値を保持するテンポラリ変数は型に係わらず、単に
tmp としましょう。

もしローカル変数の名前付けに迷っているようなら、別な問題を抱えているもの
です。「関数成長ホルモン不均衡症候群」と呼ばれています。詳しくは第６章（
関数）を見てください。



                第５章 - Typedef

"vps_t" のような定義は使わないでください。

        vps_t a;

構造体やポインタに typedef を使うことが間違っています。ソース上で、
「vps_t a;」という文を見たとき、どんな意味があると考えますか？

        struct virtual_container *a;

対照的に、「struct virtual_container *a;」なら、"a" が何であるか、実際
に言い当てることができます。


typedef の定義は「読みやすさの手助け」になると、多くの人々は考えています。
しかしそうではありません。typedef は次の場合にだけ役に立ちます。

 (a) 内部を知る必要ないオブジェクト（そのオブジェクトが何であるかを隠蔽す
     るため、積極的に typedef を使用する場合）

     例えば - "pte_t" などの、適切な操作関数を使ってのみアクセスする
     ことができる、内部を知る必要のないオブジェクト。

     ここで注意です！内部を知る必要ないデータ構造と「操作関数」は、それ
     自体良くありません。pte_t などがそうなっている理由は、移植性のある
     アクセス可能な情報が完全に「なにもない」からです。

 (b) int 型か long 型か考慮する必要なく、抽象化によって整数型だということ
     だけをはっきりさせたい場合。

     このカテゴリより、カテゴリ(d) に関連しますが、u8/u16/u32 は何の問題も
     ない typedef 定義です。

     再度注意です！これには理由が必要です。unsined long 型として扱える変
     数の型を以下のように再定義する理由は何もありません。

        typedef unsigned long myflags_t;

     ある環境では unsigned int 型であり、他の環境では unsigned long 型で
     あるようなはっきりとした理由がある場合には、ぜひとも typedef を使っ
     てください。

 (c) sparse ツールを使った型チェック用に、文字通り「新しい型」を定義する
     場合。

 (d) 特例として、C99 で導入された新しい標準型と同じ型を定義する場合。

     目と脳は「uint32_t」のような標準型にすぐ慣れますが、それでもこのよう
     な型を使うことに反対する人たちがいます。

     そのため、C99の標準型と全く同じですが、Linux 特有の u8/u16/u32/u64
     という型と、それらの符号付きの型が定義されています。 - といっても、
     あなたが新しいコードを書くときに、これらを必ず使わなくてはならない
     わけではありません。

     これらのうちいくつかの型を使用している既存のコードを編集する場合には、
     元々のコードに従ってください。

 (e) ユーザー空間で安全に使用するための型定義。

     いくつかの構造体は、ユーザー空間でも使用されます。そのような構造体
     では、C99 で定義された型や上で述べた「u32」のような型は使用できま
     せん。そのためユーザー空間と定義を共有するすべての構造体では、
     「__u32」のような型を使用します。


他のケースがあるかもしれませんが、上に挙げたルールに当てはまらない場合は、
基本的に typedef を使ってはいけません。

一般的に、ポインタや、直接アクセスされるメンバを持つ構造体は、決して
typedef してはいけません。


                第６章 - 関数

関数は短くて親切、かつ単純に一つのことを行いましょう。各関数は（皆が知っ
ている ISO/ANSI 画面80文字x24行で）１画面か２画面に収めましょう。一つの
関数は一つの処理に専念して、それだけをキッチリと行いましょう。

許される関数の長さは、その関数の複雑さと関数内のインデントの深さに反比例
します。本質的には単純な関数ですが、長い（けれど単純な）switch case 構文
を含む関数があったとします。たくさんの case が、それぞれで異なるちょっと
した処理を行うのであれば、関数全体が長くなっても良いでしょう。

あなたが複雑な関数を作成してしまい、「平凡な高校１年生では決して、この関
数の全てを理解できないだろうな」と感じたら、相手を思いやる意味での最大限
の対策を施してください。その際には、わかり易い名前の補助関数を利用してく
ださい（関数呼び出しに伴う性能低下を懸念するのであれば、コンパイラへイン
ライン展開を要求しましょう。自分でやるよりずっと上手に対処してくれること
でしょう）。

関数内のローカル変数の数も目安となります。ローカル変数は５～１０個にとど
めるべきもので、それを超えているようなら何か悪いことをしているのです。そ
ういう場合は関数を見直し、より細かく分割してください。一般的に、人間の脳
が余裕を持って同時に追えることは７つくらいが限界で、それ以上あると混乱し
てしまいます。自分の素晴らしさは自分が一番知っていることでしょう、がしか
し、２週間前に書いたものがすぐに分かると嬉しいとは思いませんか？


ソースファイル内では、空行１行で関数を区切ってください。関数がエクスポート
されている場合、関数の終了括弧のある行のすぐ後に EXPORT* マクロを置くべきで
す。例 -

int system_is_up(void)
{
        return system_state == SYSTEM_RUNNING;
}
EXPORT_SYMBOL(system_is_up);

関数プロトタイプ内には、データの型と一緒に、パラメータ名を含めてください。
これはＣ言語にとって、仕様上、必要ではありませんが、読み手にとって価値のあ
る情報を加える簡単な方法なので、Linux では推奨されます。


                第７章 - 関数終了コードの共通化(goto out)


goto 構文の利用に否定的な人もいますが、コンパイラは goto 構文に等しい無
条件 jump 命令を頻繁に出力しているのです。

goto 構文は、関数がいくつかの場所で処理を終了してから共通的な動作（例え
ばクリーンアップ動作）を行う場合に重宝します。

その論拠として以下のようなことがあります。


- 条件の無い文は理解しやすく、処理の流れを追うのも容易
- ネストが減る
- 修正の際、個別に実装した終了処理の一部を更新し忘れる、という誤りを予防
   できる
- 冗長なコードを取り除き、最適化できるようコンパイラを手助けする


int fun(int a)
{
        int result = 0;
        char *buffer = kmalloc(SIZE);

        if (buffer == NULL) {
                return -ENOMEM;
        }

        if (condition1) {
                while (loop1) {
                        ...
                }
                result = 1;
                goto out;
        }
        ...
out:
        kfree(buffer);
        return result;
}


                第８章 - コメント

コメントは役立つものですが、コメントの付けすぎも危険なことを意識してくだ
さい。決して、コメントでプログラムの仕組みを説明しようとしてはいけません。
 - どう動くかが明瞭なコードを書く方が遥かによいことです。
   悲惨なコードの説明に時間を掛けることは無駄です。



一般的に、コメントでコードが何をしているのか(WHAT)を示そうとはしますが、
どうやっているのか（HOW）は示さないでしょう。また、関数の中にコメントを記
載することは避けましょう - 関数が複雑なので、別途に関数の説明コメントが必
要と考えるのであれば、第６章を読み直してください。「極めて巧妙なワザ（汚い
手ともいう）を使ったよ」と注意したい時にはちょっとしたコメントを付けても良
いですが、やりすぎないでください。それよりも、関数の先頭にコメントを付与し、
何をする関数なのか、さらに可能であれば、何故それをするのかまで示しましょう。


カーネル API 関数へコメントを付ける場合は、kernel-doc 形式を利用してくださ
い。詳細は Documentation/kernel-doc-nano-HOWTO.txt、scripts/kernel-doc に
あります。

Linux カーネルにおけるコメントスタイルは、C89 の "/* ... */" スタイルです。
C99 スタイルの "// ..." のコメントは使用してはいけません。


長い（複数行にわたる）コメントにとって推奨されるスタイルを次に示します。

        /*
         * この形式が、Linux カーネルソースコード内の複数行のコメントにお
         * いて推奨されるスタイルです。
         * 一貫して、それを使用してください。
         *
         * 説明 - 左側にアスタリスクの列を置き、開始行と終了行には、ほとん
         * どなにもない行を置いてください。
         */

基本型または派生型であるかどうかに関わらず、データにコメントすることも、重
要です。そのために、（カンマを用いて、複数のデータ宣言をせず）、１行につき
１つのデータを宣言してください。そうすることで、データ毎に、使用方法を説明
する為の短いコメントを記述する余地ができます。


                第１１章 - データ構造

あるデータ構造を特定のスレッド（コンテキスト）が生成・破棄する一方で、ス
レッドの外側からも参照できる場合、そういったデータ構造には常に参照カウン
タが必要です。カーネル内部にはガーベッジコレクションが存在しません（そし
て、カーネル外部のガーベッジコレクションは低速で非効率です）。従って、利
用する全てのデータは必ず参照カウントしなければなりません。


参照カウントによって、データ構造へのロックが避けられ、さらに複数ユーザー
（スレッドなどのコンテキスト）から並行して同じデータ構造へアクセスできま
す - 参照中に sleep や別の処理を行ったからといって、参照していたデータ構
造に不意にアクセスできなくなる心配は不要です。


ここで一つ注意しておきます。ロックは、参照カウンタの代わりにはなりません。
ロックは、データの一貫性を保つのに使います、一方、参照カウンタは、メモリ管
理において利用されます。通常、両方とも必要であり、互いに混同してはいけません。

実は多くのデータ構造は、異なる "class" のユーザーを持つ場合において、２段
階の参照カウンタを持っています。subclass カウンタは subclass ユーザー数を
カウントし、カウンタが０になった場合に限ってグローバルカウンタをデクリメ
ントします。

この多段階の参照カウンタの例が、メモリ管理に見受けられます（mm_struct
構造体の mm_users と mm_count です）。ファイルシステムのコードにも見受けら
れます（super_block 構造体の s_count と s_active です）。


覚えておいてください - 別のスレッドがあなたのデータ構造を探すことができる
のに、あなたはそのデータ構造に参照カウンタを持っていないとすると、ほぼ確
実にバグを引き起こします。


                第１２章 - マクロ、列挙型および RTL

定数を定義するマクロの名前と列挙定数は大文字で記述します。


#define CONSTANT 0x12345

列挙型は複数の関連する定数を定義するときに好んで利用されます。

マクロは大文字が好ましいですが、関数形式マクロは小文字でも構いません。

一般的に、関数形式マクロよりもインライン関数の方が望ましいでしょう。

複数の文から構成されるマクロは do - while ブロックで囲むべきです。


#define macrofun(a, b, c)               \
        do {                            \
                if (a == 5) {           \
                        do_this(b, c);  \
                }                       \
        } while (0)


マクロ使用時に避けるべきこと -


1) 制御の流れに影響を与えるマクロ -

#define FOO(x)                               \
        do {                                 \
                if (blah(x) < 0) {           \
                        return -EBUGGERED;   \
                }                            \
        } while(0)

このマクロは非常に悪いアイデアです。関数呼び出しのように見えながら、「呼
んだ」関数から抜けてしまいます - コードを読む人々の頭の中のパーサを壊して
はいけません。

2) 特定の名前のローカル変数に依存しているマクロ


#define FOO(val) bar(index, val)

このマクロは良いことのように見えるかもしれませんが、誰かがコードを読む際
に地獄のように混乱させるし、表面上、問題の無い変更が処理を壊す傾向にあり
ます。

3) 左辺値として使われる引数付マクロ - FOO(x) = y - 例えば、もし誰かがこの
   マクロをインライン関数に変更しようとすれば文句を言われるでしょう。

4) 演算子の優先度について忘れること - 式で定数を定義するマクロは式を括弧で
   囲まなければなりません。引数を利用するマクロの同じような問題に用心しまし
   ょう。


#define CONSTANT 0x4000
#define CONSTEXP (CONSTANT | 3)

マクロの詳細については cpp マニュアルを参照してください。カーネルの中でア
センブリ言語と供によく利用される RTL については gcc インターナルマニュアル
を参照しましょう。
