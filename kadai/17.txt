続wcount

【目的】
本問題は、HULFT開発部伝統のC言語課題wcountを改題したものです。
オリジナルのwcountは、実践力が身につく問題のため改題して再利用しました。
本問題では、オリジナルのwcountにはない、以下の観点の学びを得られるようにしました。

1. OSSを使った開発を経験する
2. ソフトウェア設計を意識したプログラミングを経験する


【問題】
wcountの入出力先を以下のusageのように動作するように拡張してください。
オリジナルwcountで実装したDBのことをここでは「huldb」と呼びます。

```
wcount -i {file=file_name|huldb=db_name|sqlite=db_name:table_name} [-o {json|huldb=db_name|sqlite=db_name:table_name}]
```

【仕様】
基本的にはオリジナルwcountの仕様に従うこと。

■入出力形式について
処理結果は用途に分けて以下を指定できるようにしてください。

	- sqlite
		SQLiteを使用し、データベースの指定されたテーブルを操作します。
		指定されたデータベースファイルが存在しない場合は、実行時にテーブルも含め作成してください。
		SQLiteを使用するにあたり、必要な情報は各自調査してください（調査力をつけるため）。
		テーブル名は128バイトで命名規則は自由とし、実行時に対象のテーブルを選べるようにしてください。
		ただしテーブルのスキーマ自体は次のようにしてください。
		Column |          Type           |
		-------+-------------------------+
		word   | character varying(1024) |
		count  | integer                 |

		主キーはwordにしてください。
		入力にSQLITEを指定した際に、DBが存在しない場合は何も出力せず終了すること（単に読み込むものがなかったため正常終了）

	- json
		json形式で標準出力に出力を行ってください。
		ファイルに出力する場合はリダイレクトすればいいので、JSON形式のファイル出力機能は不要です。
		また、JSON出力は外部プログラムとの連携にのみ使用するため、JSON形式の入力は不要です。
		C言語でjsonを扱うOSSはいくつかありますが、cJSON(https://github.com/DaveGamble/cJSON)を推奨とします。
		他のOSSでも問題ありませんが、解答はcJSONで作成しています。
		出力時は空白の調整などは不要です。
		json出力時のフォーマットは以下のようにしてください。
		Total of countには単語数の総計をTotal of wordには単語の種類をセットしてください。

		```
		{
		    "Total of count":        580,
		    "Total of word": 90,
		    "word count list": {
		        "and": 98
		        "are": 21
		 		...
		    }
		}
		```

	- 標準出力
		標準出力の場合は見やすさを考慮し、単語出現数の降順でソートしてください。
		ただし、出現数が同じ場合は辞書順で出力してください。
		出力フォーマットはオリジナルwcountに従ってください。

	- huldb
		オリジナルwcountに従ってください。


■エラー処理について
オリジナルwcountのエラーに以下の２つのエラーを追加してください。
終了コード |  内容                      |   メッセージ        |  備考
-----------+----------------------------+---------------------+--------------------------------------------
    7      |  JSON関連処理のエラー      |   cJSON error.      |  cJSONの箇所は使用するライブラリ名にすること
    8      |  SQLITE関連処理のエラー    |   sqlite error: %s  |  %sにはSQLITEのエラーメッセージを出力すること


【実行例】
（１）wcount -i file=hoge 
	hogeというファイルを読み込んで結果を標準出力に出力。
	標準出力に出力するため、出力結果はcountの降順にすること。

（２）wcount -i sqlite=fuga.db:wcount -o json
	fuga.dbのwcountテーブルを読み込んで結果を標準出力にJSON形式で出力。

（３）wcount -i file=hoge -o huldb=db_name
	hogeというファイルを読み込んで結果をhuldbに出力。
	UPDATE時に元のcount数を足すことを忘れないこと。

（４）wcount -i huldb=piyo.db -o sqlite=fuga.db:wcount
	piyo.dbというhuldbファイルを読み込んで結果をfuga.dbに出力。
	UPDATE時に元のcount数を足すことを忘れないこと。

（５）wcount -i sqlite=fuga.db:wcount -o sqlite=fuga.db:wcount
	fuga.dbのwcountテーブルを読み込んで結果をfuga.dbに再出力。
	入力先と出力先が同じなので結果的にcountが倍になる（つまり実行前にcountが2だったものが実行後は4になる）。


【実装について】
今回の課題は、以下のことに注意して実装を行ってください。
（１）各機能ごとにファイルを分割し、分割コンパイルができるようにすること
（２）各コンポーネント（機能分割したときのそれぞれの部品）間で循環依存させないこと
（３）将来的に入出力先が増えた場合に、既存コードの変更をほとんどせずに、コードの追加により機能拡張ができるようにすること

（１）は必須、（２）、（３）は努力目標とします。
上記3つに対応するには、実装前の設計が大切です。
設計自体はレビュー対象とはしませんが、コードをすぐに書くのではなく、どの情報（構造体の定義やマクロなど）がどのファイルにあるべきか、
どのファイルと依存関係を持たせるかなどなどいろいろと考えてから実装を開始してみてください。
ちなみにコードをよりよくするために設計と実装を繰り返しやって、何度も何度も書き直すというのは実際の現場でもあるあるです。

前述の通り、（２）、（３）は努力目標なので、完璧を追求する必要はありません。
この問題には解答例と解説を用意しているので、最終的にはそれらを読んで勉強してみてください。

